
https://dashboard.heroku.com/apps/soundanalyzerng
https://soundanalyzerng.herokuapp.com/
https://github.com/mcoons/soundAnalyzerNg


Ribbon Particle Shapes
https://www.babylonjs-playground.com/#1HSC2O#242


FFT Info
https://www.rationalacoustics.com/files/FFT_Fundamentals.pdf







BUGS
_______________________________________________________________________


Fix/remove mirror on Rings

Fix the slight Y offset issue that happens during explosion - if only 1 selected then dont explode
Fix playlist selection button highlight when canceling coming from mic



DEFAULTS
_______________________________________________________________________

Fix all defaults for light rig rotations
Fix all defaults for light glow intensity
Fix all defaults for Custom Colors (remove middle black)



TODO
_______________________________________________________________________

Revamp saving of favorite to only save specific visual instead of whole visual arrays
Name should be based off of visual type

Check into that separate Audio module 

Create a materialManager service.

Create new UI with components
    Strength/Gain should be -100 to +100
    Add a hack to all sliders to only update when completed (have I done this some place?)
    Add Audio tab with adjustments
    Add image save capability.

SCENE options
    Glow Layer Intensity Adjustment

    Allow auto rotation of light rigs
    Allow auto rotation of camera rig
        Add sin() to camera movement
    Allow auto rotation of object

    Allow toggle of highlight layer & highlight color
    Allow toggle of glow layer & color

    Re order lights so thy can be controlled per material 
    4 light material = top, left, front, camera
    8 light material = bottom, right, back, rimlight

AUDIO options
    Adjust gain per octive
    data Source selection

Camera Options
    Focus
    Aperture
    

Add "None" option for Visuals that skips render loop (can be used while viewing bars)
Add Dynamic viewing of different data Bar graphs
Add selection of different data sets - Rewrite all to use data.length to build/update

Rename components to be more generic and uniform by type name for grouping

Add Favorites/Visuals for end users.
Saving, importing, exporting Favorites.

Split Paid/Free options
Add universal materials for all visuals to use to allow material options
PBR 
Standard 4
Standard 8

Implement 2D history layer in the back.



FUTURE VISUAL IDEAS

Implement Star Zooming
A crystal ball with flickering light inside - Lindsey - When the stars align
Dancing sign waves in smoke with a realistic look
Turn Sphere Plane 2 into an Exploding SPS



Multiple particle emitters. 7 total 1 per octive .

Amount:
Color:
Age:
Speed:



Predefined shape.  Fill it out more per.

Multiple Cameras with scene fading???





Check for CSS cross browser changes

Make the main player size constant
Clean up messaging.
Pick a library to use and update code - Bootstrap, BootstrapNg, Material 
Make variables private and assign types where possible
Do something cool with Title
Add auto change of visual between songs.  User selectable list?

Add multiple scenes, one for each visual, then render the current selected scene

Add testing (Karma, Jasmine)

Determine relation between pixels on all layers 
 a) where top of player div relates to 2d canvas  DONE
 b) cast ray from 2d pt into 3d
 c) div to 3d

----------------------------------------------------------------------



angular is wrapped by an express server for prod deployment on Heroku

    to build prod for express server
    ng build --aot --prod

    to run prod express server on localhost:8080
    node server.js       

    to run local ng dev server on localhost:4200
    ng serve


To Reduce a Large Heroku Slug Size
    heroku plugins:install heroku-repo

    heroku repo:gc --app soundanalyzerng
    heroku repo:purge_cache --app soundanalyzerng

Audio Node Mapping

            audioSrc   <-  volume
                |
            tdAnalyser
                |
             splitter
             /      \
       gainNode     destination
           |
       analysers           


AudioNode.connect(destination)
AudioNode.disconnect();

MediaStreamTrackAudioSourceNode
BiquadFilterNode




// 12th root of 2 for 1 key


/*
      this.fr64DataArray,  // 0
      this.fr128DataArray, // 1
      this.fr256DataArray,
      this.fr512DataArray,
      this.fr1024DataArray,
      this.fr2048DataArray,
      this.fr4096DataArray,
      this.fr8192DataArray,
      this.fr16384DataArray // 8
*/

// Low f           64                 +               64              High f          64-128 of 128
//         64      +       64         +        64      +       64                     64-128 of 256
//     64  +   64  +   64  +   64     +    64  +   64  +   64  +   64                 64-128 of 512
//   64+64 + 64+64 + 64+64 + 64+64    +  64+64 + 64+64 + 64+64 + 64+64                64-128 of 1024
//                                                                                    64-128 of 2048
//                                                                                    64-128 of 4096
//                                                                                    64-128 of 8192
//                                                                                   0-128 of 16384

//                                                                             32*9  =  288

//                                                                             0-287 objects



16 - 32 of 32
16 - 32 of 64
16 - 32 of 128
16 - 32 of 256
16 - 32 of 512
16 - 32 of 1024
16 - 32 of 2048
16 - 32 of 4096

16 X 8 =  128






1920x1200, 1680x1050, 1280x800, and 1024x640

// tslint:disable-next-line: max-line-length










M4A does not play


IN PARTICLE update

expanding

scale - lerping current to next
position - lerping current to exp local
rotation - lerping current to next
color - lerping current to next


contracting

scaling -  next
position - lerping exp loc to next
rotation - next
color - next


else   (current = next at this time)

scaling - current
position - current 
rotation - current
color - current



IN MAIN update

expanding

SPS rotation - lerping current to next
Camera - lerping current to next



contracting

SPS rotation - next



else   (current = next at this time)

SPS rotation - current




            // if (this.nextSPS <= this.currentSPS) {
            //     this.previousCameraIndex = this.currentCameraIndex;
            //     this.currentCameraIndex += 1;
            //     if (this.currentCameraIndex === 2) {
            //         this.currentCameraIndex = 0;
            //     }
            //     this.cameraSwap = true;
            //     console.log('camera swap');
            // }


            const cameraSettingsCurrent =
                // this.cameraSwap ?
                this.SPSFunctions[this.currentSPS].cameraDefault(this.currentCameraIndex) // :
                // this.SPSFunctions[this.currentSPS].cameraDefault(this.previousCameraIndex);
            const cameraSettingsNext = this.SPSFunctions[this.nextSPS].cameraDefault(this.currentCameraIndex);

            (this.scene.cameras[0] as BABYLON.ArcRotateCamera).alpha =
                BABYLON.Scalar.Lerp(
                    cameraSettingsCurrent.alpha,
                    cameraSettingsNext.alpha,
                    this.conTimer);


            (this.scene.cameras[0] as BABYLON.ArcRotateCamera).beta =
                BABYLON.Scalar.Lerp(
                    cameraSettingsCurrent.beta,
                    cameraSettingsNext.beta,
                    this.conTimer);


            (this.scene.cameras[0] as BABYLON.ArcRotateCamera).radius =
                BABYLON.Scalar.Lerp(
                    cameraSettingsCurrent.radius,
                    cameraSettingsNext.radius,
                    this.conTimer);



                    [[{"_isDirty":true,"_x":0.7071067811865476,"_y":-0.7071067811865475,"_z":-2},{"_isDirty":true,"_x":0.7071067811865476,"_y":0.7071067811865475,"_z":-2},{"_isDirty":true,"_x":-0.7071067811865475,"_y":0.7071067811865476,"_z":-2},{"_isDirty":true,"_x":-0.7071067811865477,"_y":-0.7071067811865475,"_z":-2},{"_isDirty":true,"_x":0.7071067811865474,"_y":-0.7071067811865477,"_z":-2}],[{"_isDirty":true,"_x":0.9238795325112867,"_y":-0.3826834323650898,"_z":-1},{"_isDirty":true,"_x":0.38268343236508984,"_y":0.9238795325112867,"_z":-1},{"_isDirty":true,"_x":-0.9238795325112867,"_y":0.3826834323650899,"_z":-1},{"_isDirty":true,"_x":-0.38268343236509034,"_y":-0.9238795325112865,"_z":-1},{"_isDirty":true,"_x":0.9238795325112865,"_y":-0.3826834323650904,"_z":-1}],[{"_isDirty":true,"_x":1,"_y":0,"_z":0},{"_isDirty":true,"_x":6.123233995736766e-17,"_y":1,"_z":0},{"_isDirty":true,"_x":-1,"_y":1.2246467991473532e-16,"_z":0},{"_isDirty":true,"_x":-1.8369701987210297e-16,"_y":-1,"_z":0},{"_isDirty":true,"_x":1,"_y":-2.4492935982947064e-16,"_z":0}],[{"_isDirty":true,"_x":0.9238795325112867,"_y":0.3826834323650898,"_z":1},{"_isDirty":true,"_x":-0.3826834323650897,"_y":0.9238795325112867,"_z":1},{"_isDirty":true,"_x":-0.9238795325112868,"_y":-0.38268343236508967,"_z":1},{"_isDirty":true,"_x":0.38268343236509,"_y":-0.9238795325112866,"_z":1},{"_isDirty":true,"_x":0.9238795325112867,"_y":0.38268343236508995,"_z":1}],[{"_isDirty":true,"_x":0.7071067811865476,"_y":0.7071067811865475,"_z":2},{"_isDirty":true,"_x":-0.7071067811865475,"_y":0.7071067811865476,"_z":2},{"_isDirty":true,"_x":-0.7071067811865477,"_y":-0.7071067811865475,"_z":2},{"_isDirty":true,"_x":0.7071067811865474,"_y":-0.7071067811865477,"_z":2},{"_isDirty":true,"_x":0.7071067811865477,"_y":0.7071067811865474,"_z":2}]]









HEX
        this.hexMat = new BABYLON.StandardMaterial(`material`, this.scene);
        this.hexMat.bumpTexture = new BABYLON.Texture('../../assets/images/normal8.jpg', this.scene);
        this.hexMat.bumpTexture.uScale = 5;
        this.hexMat.bumpTexture.vScale = 5;
        // this.hexMat.emmisiveColor =


RINGS
        this.mat = new BABYLON.StandardMaterial('mat1', this.scene);
        this.mat.diffuseTexture = new BABYLON.Texture('../../assets/mats/glow2.png', this.scene);
        this.mat.backFaceCulling = false;
        this.mat.opacityTexture = new BABYLON.Texture('../../assets/mats/glow2.png', this.scene);
        this.mat.specularColor = new BABYLON.Color3(0, 0, 0);

        this.mat.diffuseTexture.hasAlpha = true;
        (this.mat.diffuseTexture as BABYLON.Texture).vScale = 1 / 5;
        (this.mat.opacityTexture as BABYLON.Texture).vScale = 1 / 5;


SPS CUBE
       this.mat = new BABYLON.StandardMaterial('mat1', this.scene);
        this.mat.backFaceCulling = false;
        this.mat.specularColor = new BABYLON.Color3(0, 0, 0);
        this.mat.ambientColor = new BABYLON.Color3(.25, .25, .25);
        this.mat.forceDepthWrite = true;
        // this.mat.reflectionTexture = new BABYLON.CubeTexture('../../assets/images/skybox/TropicalSunnyDay', this.scene);
        // this.mat.reflectionTexture.coordinatesMode = BABYLON.Texture.PLANAR_MODE;

SPECTROGRAPH
        this.ground.material = new BABYLON.StandardMaterial('gmat', this.scene);
        this.ground.material.backFaceCulling = false;
        this.ground.material.specularColor = new BABYLON.Color3(0, 0, 0); // black is no shine






New Base Options



Favorites[]
State{}
Options{}
    General{}
    Visual[]















    const SPS = new BABYLON.SolidParticleSystem("SPS", scene);
    const tetra = BABYLON.MeshBuilder.CreatePolyhedron("tetra", {size: 1});
    SPS.addShape(tetra, 1000);
    tetra.dispose();

    const mesh = SPS.buildMesh(); // finally builds and displays the SPS mesh
    
    // recycle particles function
    //sets particles to an intial state
    recycleParticle = (particle) => { 
        ... 
        
    }

    //Initate by recycling through all particles
    SPS.initParticles = () => {
        for (let p = 0; p < SPS.nbParticles; p++) {
            recycleParticle(SPS.particles[p])
        }
    }


    //Initiate SPS mesh
    SPS.initParticles();
    SPS.setParticles();

    //Update function
    SPS.updateParticle = (particle) => {